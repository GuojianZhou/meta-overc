#!/bin/bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

mydir=`dirname $0`
PATH=$mydir:$PATH

usage()
{
cat << EOF

  cube-cfg [--clean] <command> <value>

global options:
    
 --clean: remove artifacts before performing <command>
 -o     : output/config directory
 -n     : container name

commands (and options):

 ${0##*/} gen <name>:<type>

    generate a base configuration

       <name>:<type> container name and type

 ${0##*/} [-n <container name>] mount <type>:<name>:<name>

    mount a directory into the container

       <type>:       optional type of mount. 'bind'
       <name>:<name> source and destination directory

 ${0##*/} [-n <container name>] hook <type>:<name>

    add a hook into the container lifecycle

       <type>       type of hook: prestart or poststop
       <name>       full path to the hook

 ${0##*/} [-n <container name>] device <type>:<name>:<name>

    add a device to a container

       <type>:       network or console/tty
       <name>:<name> device name in essential : device name in container

 ${0##*/} [-n <container name>] [-o <output dir>] set <setting>:<value>
 ${0##*/} [-n <container name>] [-o <output dir>] get <setting>

    valid settings are:

        cube.container.mgr     The manager for the container
        cube.console.mgr       The console manager (if access is not direct)
        autostart              The autostart manager for the container
        app                    The application to start in the container

EOF
}

if [ -z "$1" ]; then
    usage
    exit
fi

# take the entire command into an array
raw_command=($@)

force=""
peer=t
non_dashed=""
out_dir="./"

# this corresponds to the lxc.id_map items within the container's config file
DEFAULT_SUBUID=800000

while [ $# -gt 0 ]; do
    case "$1" in
	-v) verbose=t
            ;;
	--clean)
	    clean=t
	    ;;
        --peer)
	    peer=t
	    nested=
	    ;;
	--nested)
	    nested=t
	    peer=
	    ;;
	--parent)
	    parent=${2}
	    shift
	    ;;
	--name)
	    container_name_temp=${2}
	    shift
	    ;;
	-u)
		# This is an unprivileged container. We need to config subuid/subgid.
		if [ "${2}" -eq "${2}" ] 2>/dev/null; then
			if [ "${2}" -lt 100000 ] 2>/dev/null; then
				echo "Error: -u requires a subuid number no less than 100000"
				exit 1
			fi
			subuid="${2}"
			shift
		else
			subuid="${DEFAULT_SUBUID}"
		fi
		;;
	-F)
	    force=-F
	    ;;
        --n|-n)
	    container_name=${2}
	    shift
	    ;;
        --t|-t)
	    container_type=${2}
	    shift
	    ;;
        --o|-o)
	    out_dir=${2}
	    shift
	    ;;
	-h|--help)
	    usage
	    exit
	    ;;
	--*)
	    # if the next argument is dashed, we just add $1 to our collection
	    # of dashed arguments. If $2 is NOT dashed, we assume it is a parameter
	    # to the --dashed option, and we grab it as well. Don't try and mix
	    # dashed and non-dashed, since we'll grab them!
	    case $2 in
		--*)
		    dashed="${dashed} $1"
		    ;;
		*)
		    # sneak a : in between, so we can split it later
		    dashed="${dashed} $1:$2"
		    shift
		    ;;
	    esac
	    ;;
        *) non_dashed="${non_dashed} $1"
            ;;
    esac
    shift
done

# if outdir wasn't passed on the command line, but a container name
# was passed, then we should check to see if the container is available
# and change the out_dir to where it is stored. This allows things
# like: 'cube-cfg -n cube-server get autostart' to work without passing
# the out_dir explicitly
if [ "${out_dir}" == "./" ]; then
    if [ -n "${container_name}" ]; then
	if [ -d "/opt/container/${container_name}" ]; then
	    out_dir="/opt/container/${container_name}"
	fi
    fi
fi

# returns 1 if we are container, 0 otherwise
function am_i_a_container()
{
    local virt_bin=$(which systemd-detect-virt)

    # if we can't run detection, just say we aren't a container
    if [ -z "${virt_bin}" ]; then
	return 0
    fi

    local virt=`systemd-detect-virt`
    case $virt in
	lxc*)
	    return 1
	    ;;
	container*)
	    return 1
	    ;;
	docker*)
	    return 1
	    ;;
    esac

    return 0
}

am_i_a_container
if [ $? -eq 1 ]; then
    we_are_a_container=t
fi

# make an array from whatever was non-dashed
cmd_options_non_dashed=(${non_dashed})

if [ -z "${cmd}" ]; then
    # the first element is the command
    cmd=${cmd_options_non_dashed[0]}
fi

check_required()
{
    if [ ! -e "${1}" ]; then
	echo "[ERROR]: required command ${1} not found, exiting"
	exit 1
    fi
}

check_if_present()
{
    if [ -e "${1}" ]; then
	return 0
    fi
    return 1
}

#
# arg1: type of artifacts to clean. if not passed, all will be
#       cleaned
#
clean_config_artifacts()
{
    local type=$1

    if [ -z "${type}" ]; then
	type="all"
    fi

    if [ "${type}" = "mount" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.mount
	rm -f ${out_dir}/.cube.mount.bind
    fi

    if [ "${type}" = "device" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.device ${out_dir}/.cube.device.network
    fi

    if [ "${type}" = "hooks" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.hooks.prestart ${out_dir}/.cube.hooks.poststop
    fi
}

#
# arg1: container name
#
# output: config.json in the current directory
#
generate_base_config()
{
    local container_name=$1

    if [ -e ".cube.mount.bind" ]; then
	for d in $(cat .cube.mount.bind); do
	    mount_args="${mount_args} --bind $d"
	done
    fi

    # TODO: these can also be cube-cfg values, but right now are
    #       restricted for compatibility reasons
    capabilities="--cap-add KILL \
		  --cap-add LINUX_IMMUTABLE \
                  --cap-add SYS_RAWIO \
                  --cap-add SYS_ADMIN \
		  --cap-add SYS_MODULE \
                  --cap-add SYS_RESOURCE \
                  --cap-add SYS_TTY_CONFIG"

    app="/sbin/init"
    if [ -e "cube.app" ]; then
	app=$(cat cube.app)
    fi

    if [ -e ".cube.hooks.prestart" ]; then
	for hook in $(cat .cube.hooks.prestart); do
	    hooks="${hooks} --prestart ${hook}"
	done
    fi
    if [ -e ".cube.hooks.poststop" ]; then
	for hook in $(cat .cube.hooks.poststop); do
	    hooks="${hooks} --poststop ${hook}"
	done
    fi
    if [ -z "${hooks}" ]; then
	# if no hooks have been passed, but the app is not /sbin/init
	# we don't need the systemd hook, just go with the network one
	if [ "${app}" = "/sbin/init" ]; then
	    hooks="--prestart /usr/libexec/oci/hooks.d/oci-systemd-hook \
	           --poststop /usrlibexec/oci/hooks.d/oci-systemd-hook"
	fi
	hooks="${hooks} --prestart /usr/libexec/oci/hooks.d/netns"
    fi

    ## TODO: if there's no oci-runtime-tool, then we should capture a
    ##       a default config.json and modify it on the fly
    oci-runtime-tool generate --tty \
	             ${hooks} \
		     --args ${app} \
                     --seccomp-remove-all \
                     --hostname=${container_name} \
		     --env container=docker \
                     ${capabilities} \
                     ${mount_args} \
                     > config.json.tmp

    sed -i 's/\"seccomp\"/\"seccomp-ignore\"/g' config.json.tmp
    # "devices" must be available for mods
    sed -i 's/\"allow\": false,/\"allow\": true,/g' config.json.tmp
    # /sys/ needs to be read-write
    sed -i 's/\"ro\"/\"rw\"/g' config.json.tmp

    mv config.json.tmp config.json

    # by default, we assume runc will manage the container, this can
    # be changed later.
    echo "runc" > cube.container.mgr
}

#
# arg1: container name
#
convert_base_config_to_cube()
{
    local container_name=$1

    rm -f pflask.config

    # any mounts ?
    for mount in $(jq -r '.mounts | map("\(.type):\(.source):\(.destination)") | .[]' config.json); do
	# we only care about bind mounts at the moment
	echo "$mount" | grep -q bind
	if [ $? -eq 0 ]; then
	    echo ${mount} >> pflask.config
	    pflask_args="${pflask_args} --mount ${mount}"
	fi
    done

    # any devices.
    # TODO: these need to come from the oci spec, like the mounts, but right
    #       now the OCI tool doesn't seem to handle it
    if [ -e ".cube.device.network" ]; then
	netdevs=$(cat .cube.device.network)
	pflask_args="${pflask_args} --netif=${netdevs}"
	echo "${netdevs}" >> pflask.config
    fi

    # what is the executable we are running ?
    app=$(jq -r  '.process.args | .[]' config.json)

    # and the root directory (to be appended to the current working dir)
    rootfs=$(jq -r  '.root.path'  config.json)
    rootfs="/opt/container/${container_name}/${rootfs}"

    pflask_args="${pflask_args}	-p ${container_name} --uncontain -d --escape-char=255 --root ${rootfs}"

    echo "#!/bin/bash" > pflask.cmd
    if [ -e "cube.console.mgr" ]; then
	grep -q "screen-tty" cube.console.mgr
	if [ $? -eq 0 ]; then
	    # The %d in the pflask command line is a sentinel value to trigger
	    # pflask to attach to it's pid (through the console command). This
	    # only works in background mode.
	    echo "export CONSOLE_CMD=\"[ -d /tmp/screens ] && /usr/bin/screen -S console -x -X screen -t ${container_name} /bin/pflask -a %d -E 255\"" >> pflask.cmd
	fi
    fi
    echo "pflask ${pflask_args} -- ${app}" >> pflask.cmd
    chmod +x pflask.cmd

    echo "pflask" > cube.container.mgr
}

case "${cmd}" in
    clean)
	clean_config_artifacts
	;;
    gen)
	name_temp=${cmd_options_non_dashed[1]}
	container_name=$(echo ${name_temp} | cut -f1 -d:)
	container_type=$(echo ${name_temp} | cut -f2 -d:)

	if [ "${container_name}" == "${container_type}" ]; then
	    container_type="oci"
	fi
	generate_base_config ${container_name}

	if [ "${container_type}" == "cube" ]; then
	    convert_base_config_to_cube ${container_name}
	fi
	;;
    mount)
	name_temp=${cmd_options_non_dashed[1]}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts mount
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 2 ]; then
	    # we have <type>:<source>:<dest>
	    source=$(echo ${name_temp} | cut -f2 -d:)
	    dest=$(echo ${name_temp} | cut -f3 -d:)

	    # save the mount information for the generation phase
	    echo "$source:$dest"  >> ${out_dir}/.cube.mount.bind
	elif [ ${colons} -eq 1 ]; then
	    # we have <source>:<dest>
	    source=$(echo ${name_temp} | cut -f1 -d:)
	    dest=$(echo ${name_temp} | cut -f2 -d:)

	    # save the mount information for the generation phase
	    echo "$source:$dest" >> ${out_dir}/.cube.mount
	else
	    echo "ERROR: Invalid mount specified ${name_temp}"
	    exit 1
	fi
	;;
    hook)
	name_temp=${cmd_options_non_dashed[1]}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts hooks
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 1 ]; then
	    # we have <source>:<dest>
	    type=$(echo ${name_temp} | cut -f1 -d:)
	    hookname=$(echo ${name_temp} | cut -f2 -d:)

	    if [ "${type}" == "prestart" ]; then
		echo "${hookname}" >> ${out_dir}/.cube.hooks.prestart
	    elif [ "${type}" == "poststop" ]; then
		echo "${hookname}" >> ${out_dir}/.cube.hooks.poststop
	    else
		echo "ERROR: invalid hook type specified ${type}"
		exit 1
	    fi
	else
	    echo "ERROR: Invalid hook specified ${name_temp}"
	    exit 1
	fi
	;;
    device|dev)
	name_temp=${cmd_options_non_dashed[1]}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts device
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 2 ]; then
	    # we have <type>:<source>:<dest>
	    device_type=$(echo ${name_temp} | cut -f1 -d:)
	    essential_device=$(echo ${name_temp} | cut -f2 -d:)
	    container_device=$(echo ${name_temp} | cut -f3 -d:)

	    # save the mount information for the generation phase
	    if [ "${device_type}" == "network" ]; then
		echo "$essential_device:$container_device"  >> ${out_dir}/.cube.device.network
	    fi
	else
	    echo "ERROR: Invalid device specified ${name_temp}"
	    exit 1
	fi
	;;
    set|get)
	var_value=${cmd_options_non_dashed[1]}
	var=$(echo ${var_value} | cut -d: -f1)
	value=$(echo ${var_value} | cut -d: -f2)

	# until we switch to a git config type format, we will only process
	# variables that we recongize, and know where to write their
	# value. They also assume you are in the directory where you want
	# the configuration written.
	case $var in
	    app)
		if [ ${cmd} = "set" ]; then
		    echo "$value" > ${out_dir}/cube.app
		elif [ ${cmd} = "get" ]; then
		    if [ -e ${out_dir}/cube.app ]; then
			cat ${out_dir}/cube.app
		    else
			echo ""
		    fi
		fi
		;;
	    cube.container.mgr)
		if [ ${cmd} = "set" ]; then
		    echo "$value" > ${out_dir}/cube.container.mgr
		elif [ ${cmd} = "get" ]; then
		    if [ -e ${out_dir}/cube.container.mgr ]; then
			cat ${out_dir}/cube.container.mgr
		    else
			echo ""
		    fi
		fi
		;;
	    cube.console.mgr)
		if [ ${cmd} = "set" ]; then
		    echo "$value" > ${out_dir}/cube.console.mgr
		elif [ ${cmd} = "get" ]; then
		    if [ -e ${out_dir}/cube.console.mgr ]; then
			cat ${out_dir}/cube.console.mgr
		    else
			echo ""
		    fi
		fi
		;;
	    autostart)
		if [ ${cmd} = "set" ]; then
		    echo "$value" > ${out_dir}/autostart
		elif [ ${cmd} = "get" ]; then
		    if [ -e ${out_dir}/autostart ]; then
			cat ${out_dir}/autostart
		    else
			echo ""
		    fi
		fi
		;;
	esac
	;;
    *)
	echo "Unknown command ..."
	usage
	;;
esac
