#!/bin/bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

mydir=`dirname $0`
PATH=$mydir:$PATH

usage()
{
cat << EOF

 cube-cfg [--clean] <command> <value>

 global options:
    
   --clean: remove artifacts before performing <command>
   -o     : output/config directory
   -n     : container name

 commands (and options):

 ${0##*/} gen <name>:<type>

    generate a base configuration

       <name>:<type> container name and type

 ${0##*/} [-n <container name>] mount <type>:<name>:<name>

    mount a directory into the container

       <type>:       optional type of mount. 'bind'
       <name>:<name> source and destination directory

 ${0##*/} [-n <container name>] hook <type>:<name>
 ${0##*/} [-n <container name>] hook-script <type>:<name>

    Add a hook into the container lifecycle

       hook         the hook is an executable
       hook-script  the hook is a script

       <type>       type of hook: prestart or poststop
       <name>       full path to the hook

 ${0##*/} [-n <container name>] device <type>:<name>:<name>

    add a device to a container

       <type>:       network, network-virt or console/tty
       <name>:<name> device name in essential : device name in container

 ${0##*/} [-n <container name>] [-o <output dir>] set <setting>:<value>
 ${0##*/} [-n <container name>] [-o <output dir>] get <setting>

    valid settings are:

EOF

for K in "${!CONFIG_MAP[@]}"; do
    help_text=$(echo "${CONFIG_MAP[$K]}" | cut -f2 -d\;)
    printf "       %-25s %s\n" "$K" "${help_text}"
done
echo ""
}

declare -A CONFIG_MAP

# The key is the variable value on the command line, followed by the
# variable to set in the database semi-colon help text
#
#  <var> <db var>; <help text>
#
CONFIG_MAP[app]="cube.app;The application to start in the container"
CONFIG_MAP[cube.container.mgr]="cube.container.mgr;The manager for the container"
CONFIG_MAP[cube.console.mgr]="cube.console.mgr;The console manager (if access is not direct)"
CONFIG_MAP[autostart]="autostart;The autostart runlevel for the container"

if [ -z "$1" ]; then
    usage
    exit
fi

# take the entire command into an array
raw_command=($@)

force=""
peer=t
non_dashed=""
out_dir="./"

# this corresponds to the lxc.id_map items within the container's config file
DEFAULT_SUBUID=800000

while [ $# -gt 0 ]; do
    case "$1" in
	-v) verbose=t
            ;;
	--dryrun)
	    dryrun=t
	    vebose=t
	    ;;
	--clean)
	    clean=t
	    ;;
        --peer)
	    peer=t
	    nested=
	    ;;
	--nested)
	    nested=t
	    peer=
	    ;;
	--parent)
	    parent=${2}
	    shift
	    ;;
	--name)
	    container_name_temp=${2}
	    shift
	    ;;
	-u)
		# This is an unprivileged container. We need to config subuid/subgid.
		if [ "${2}" -eq "${2}" ] 2>/dev/null; then
			if [ "${2}" -lt 100000 ] 2>/dev/null; then
				echo "Error: -u requires a subuid number no less than 100000"
				exit 1
			fi
			subuid="${2}"
			shift
		else
			subuid="${DEFAULT_SUBUID}"
		fi
		;;
	-F)
	    force=-F
	    ;;
        --n|-n)
	    container_name=${2}
	    shift
	    ;;
        --t|-t)
	    container_type=${2}
	    shift
	    ;;
        --o|-o)
	    out_dir=${2}
	    shift
	    ;;
	-h|--help)
	    usage
	    exit
	    ;;
	--*)
	    # if the next argument is dashed, we just add $1 to our collection
	    # of dashed arguments. If $2 is NOT dashed, we assume it is a parameter
	    # to the --dashed option, and we grab it as well. Don't try and mix
	    # dashed and non-dashed, since we'll grab them!
	    case $2 in
		--*)
		    dashed="${dashed} $1"
		    ;;
		*)
		    # sneak a : in between, so we can split it later
		    dashed="${dashed} $1:$2"
		    shift
		    ;;
	    esac
	    ;;
        *) non_dashed="${non_dashed} $1"
            ;;
    esac
    shift
done

determine_outdir()
{
    # if outdir wasn't passed on the command line, but a container name
    # was passed, then we should check to see if the container is available
    # and change the out_dir to where it is stored. This allows things
    # like: 'cube-cfg -n cube-server get autostart' to work without passing
    # the out_dir explicitly
    if [ "${out_dir}" == "./" ]; then
	if [ -n "${container_name}" ]; then
	    if [ -d "/opt/container/${container_name}" ]; then
		# but only if we have a config.json, should this actually become
		# our outdir
		if [ -f "/opt/container/${container_name}/config.json" ]; then
		    out_dir="/opt/container/${container_name}"
		fi
	    fi
	fi
    fi
}

determine_outdir

# returns 1 if we are container, 0 otherwise
function am_i_a_container()
{
    local virt_bin=$(which systemd-detect-virt)

    # if we can't run detection, just say we aren't a container
    if [ -z "${virt_bin}" ]; then
	return 0
    fi

    local virt=`systemd-detect-virt`
    case $virt in
	lxc*)
	    return 1
	    ;;
	container*)
	    return 1
	    ;;
	docker*)
	    return 1
	    ;;
    esac

    return 0
}

am_i_a_container
if [ $? -eq 1 ]; then
    we_are_a_container=t
fi

# make an array from whatever was non-dashed
cmd_options_non_dashed=(${non_dashed})

if [ -z "${cmd}" ]; then
    # the first element is the command
    cmd=${cmd_options_non_dashed[0]}
fi

check_required()
{
    if [ ! -e "${1}" ]; then
	echo "[ERROR]: required command ${1} not found, exiting"
	exit 1
    fi
}

check_if_present()
{
    if [ -e "${1}" ]; then
	return 0
    fi
    return 1
}

#
# arg1: type of artifacts to clean. if not passed, all will be
#       cleaned
#
clean_config_artifacts()
{
    local type=$1

    if [ -z "${type}" ]; then
	type="all"
    fi

    if [ "${type}" = "mount" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.mount
	rm -f ${out_dir}/.cube.mount.bind
    fi

    if [ "${type}" = "device" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.device ${out_dir}/.cube.device.network
    fi

    if [ "${type}" = "hooks" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.hooks.prestart ${out_dir}/.cube.hooks.poststop
    fi
}

#
# arg1: container name
#
# output: config.json in the current directory
#
generate_base_config()
{
    local container_name=$1

    if [ -e ".cube.mount.bind" ]; then
	for d in $(cat .cube.mount.bind); do
	    mount_args="${mount_args} --bind $d"
	done
    fi

    # TODO: these can also be cube-cfg values, but right now are
    #       restricted for compatibility reasons
    capabilities="--cap-add KILL \
		  --cap-add LINUX_IMMUTABLE \
                  --cap-add SYS_RAWIO \
                  --cap-add SYS_ADMIN \
		  --cap-add SYS_MODULE \
                  --cap-add SYS_RESOURCE \
                  --cap-add SYS_TTY_CONFIG"

    app="/sbin/init"
    if [ -e "cube.app" ]; then
	app=$(cat cube.app)
    fi

    OLDIFS=$IFS
IFS='
'
    if [ -e ".cube.hooks.prestart" ]; then
	for hook in $(cat .cube.hooks.prestart); do
	    cmd=$(echo ${hook} | cut -d' ' -f1)
	    count=$(echo ${hook} | wc -w)
	    if [ $count -gt 1 ]; then
		# the oci generation tool will take : separated items as arguments
		# to the main executable. So we replace our spaces with : to get
		# everything into the config.json
		args=$(echo ${hook} | sed 's/ /:/g')
		hooks="${hooks} --prestart ${cmd}:${args}"
	    else
		hooks="${hooks} --prestart ${cmd}"
	    fi
	done
    fi
    if [ -e ".cube.hooks.poststop" ]; then
	for hook in $(cat .cube.hooks.poststop); do
	    cmd=$(echo ${hook} | cut -d' ' -f1)
	    count=$(echo ${hook} | wc -w)
	    if [ $count -gt 1 ]; then
		# the oci generation tool will take : separated items as arguments
		# to the main executable. So we replace our spaces with : to get
		# everything into the config.json
		args=$(echo ${hook} | sed 's/ /:/g')
		hooks="${hooks} --poststop ${cmd}:${args}"
	    else
		hooks="${hooks} --poststop ${cmd}"
	    fi
	done
    fi
    IFS=$OLDIFS

    if [ -z "${hooks}" ]; then
	# if no hooks have been passed, but the app is not /sbin/init
	# we don't need the systemd hook, just go with the network one
	if [ "${app}" = "/sbin/init" ]; then
	    hooks="--prestart /usr/libexec/oci/hooks.d/oci-systemd-hook \
	           --poststop /usrlibexec/oci/hooks.d/oci-systemd-hook"
	fi
	hooks="${hooks} --prestart /usr/libexec/oci/hooks.d/netns"
    fi

    ## TODO: if there's no oci-runtime-tool, then we should capture a
    ##       a default config.json and modify it on the fly
    oci-runtime-tool generate --tty \
	             ${hooks} \
		     --args ${app} \
                     --seccomp-remove-all \
                     --hostname=${container_name} \
		     --env container=docker \
                     ${capabilities} \
                     ${mount_args} \
                     > config.json.tmp

    # fixup: disable seccomp completely by making it a section that is ignored
    sed -i 's/\"seccomp\"/\"seccomp-ignore\"/g' config.json.tmp
    # fixup: "devices" must be available for mods
    sed -i 's/\"allow\": false,/\"allow\": true,/g' config.json.tmp
    # fixup: /sys/ needs to be read-write
    sed -i 's/\"ro\"/\"rw\"/g' config.json.tmp

    # fixup: hooks have been encoded with ##space## to get the arguments properly
    #        into the json for shell script hooks. We need to change these back to
    #        real spaces.
    sed -i 's/\#\#space\#\#/ /g' config.json.tmp    

    mv config.json.tmp config.json

    # by default, we assume runc will manage the container, this can
    # be changed later.
    if [ ! -e cube.container.mgr ]; then
	echo "runc" > cube.container.mgr
    fi
}

#
# arg1: container name
#
convert_base_config_to_cube()
{
    local container_name=$1

    rm -f pflask.config

    # any mounts ?
    for mount in $(jq -r '.mounts | map("\(.type):\(.source):\(.destination)") | .[]' config.json); do
	# we only care about bind mounts at the moment
	echo "$mount" | grep -q bind
	if [ $? -eq 0 ]; then
	    echo ${mount} >> pflask.config
	    pflask_args="${pflask_args} --mount ${mount}"
	fi
    done

    # any devices.
    # TODO: these need to come from the oci spec, like the mounts, but right
    #       now the OCI tool doesn't seem to handle it
    if [ -e ".cube.device.network" ]; then
	netdevs=$(cat .cube.device.network)
	for n in ${netdevs}; do
	    pflask_args="${pflask_args} --netif=${n}"
	done
	echo "${netdevs}" >> pflask.config
    fi

    # hooks ?
    prestart_hooks=$(jq -r '.hooks.prestart' config.json)
    if [ "${prestart_hooks}" != "null" ]; then
	prestart_hooks=$(jq -r '.hooks.prestart | map("\(.path) \(.args)") | . []' config.json)
    fi
    poststop_hooks=$(jq -r '.hooks.poststop' config.json)
    if [ "${poststop_hooks}" != "null" ]; then
	poststopt_hooks=$(jq -r '.hooks.poststop| map("\(.path) \(.args)") | . []' config.json)
    fi

    # what is the executable we are running ?
    app=$(jq -r  '.process.args | .[]' config.json)

    # and the root directory (to be appended to the current working dir)
    rootfs=$(jq -r  '.root.path'  config.json)
    rootfs="/opt/container/${container_name}/${rootfs}"

    pflask_args="${pflask_args}	-p ${container_name} --uncontain -d --escape-char=255 --root ${rootfs}"

    echo "#!/bin/bash" > pflask.cmd
    if [ -e "cube.console.mgr" ]; then
	grep -q "screen-tty" cube.console.mgr
	if [ $? -eq 0 ]; then
	    # The %d in the pflask command line is a sentinel value to trigger
	    # pflask to attach to it's pid (through the console command). This
	    # only works in background mode.
	    echo "export CONSOLE_CMD=\"[ -d /tmp/screens ] && /usr/bin/screen -S console -x -X screen -t ${container_name} /bin/pflask -a %d -E 255\"" >> pflask.cmd
	fi
    fi
    echo "pflask ${pflask_args} -- ${app}" >> pflask.cmd

    if [ -n "${prestart_hooks}" ]; then
	# let's give the container time to start. this may go away later.
	echo "sleep 0.5" >> pflask.cmd
	OLDIFS=$IFS
IFS='
'
	for h in ${prestart_hooks}; do
	    # drop any "null" strings, since that means "no args"
	    h=$(echo "${h}" | sed 's/null//g')

	    # args are in an array i.e. ["sh","-c","/usr/libexec/oci/hooks.d/oci-network down $(cat)"]
	    # so we test for the brackets and replace the hook with the output
	    echo "${h}" | grep -q "\["
	    if [ $? -eq 0 ]; then
		zztop=$(echo ${h} | sed -e 's/.*\[\(.*\)\]/\1/')
		if [ -n "${zztop}" ]; then
		    zztop=$(echo ${zztop} | tr -d '"')
		    zztop=$(echo ${zztop} | sed 's/,/ /g')
		    h=${zztop}
		fi
	    fi

	    # put the conditioned hook into the pflask command
	    echo "${h}" >> pflask.cmd
	done
	IFS=$OLDIFS
    fi

    chmod +x pflask.cmd
    echo "pflask" > cube.container.mgr
}

fetch_from_etcd()
{
    local key=$1

    local key_dir=$(dirname ${key})
    local key_name=$(basename ${key})
    local etcdctl=etcdctl

    if [ -n "${dryrun}" ]; then
	etcdctl="echo etcdctl"
    fi

    if [ -n "${verbose}" ]; then
	echo "[INFO]: fetching ${key}"
    fi

    eval ${etcdctl} get ${key_dir}/${key_name}
    if [ $? -ne 0 ]; then
	echo "ERROR: Could not inject ${key} to etcd data store"
	return
    fi
}

inject_to_etcd()
{
    local key=$1
    local value=$2

    local key_dir=$(dirname ${key})
    local key_name=$(basename ${key})
    local etcdctl=etcdctl

    if [ -n "${dryrun}" ]; then
	etcdctl="echo etcdctl"
    fi

    if [ -n "${verbose}" ]; then
	echo "[INFO]: injecting ${key}:${value}"
    fi

    eval ${etcdctl} set ${key_dir}/${key_name} ${value} > /dev/null
    if [ $? -ne 0 ]; then
	echo "ERROR: Could not inject ${key} to etcd data store"
	return
    fi
}

case "${cmd}" in
    clean)
	clean_config_artifacts
	;;
    gen)
	name_temp=${cmd_options_non_dashed[1]}
	container_name=$(echo ${name_temp} | cut -f1 -d:)
	container_type=$(echo ${name_temp} | cut -f2 -d:)

	determine_outdir

	if [ "${container_name}" == "${container_type}" ]; then
	    container_type="oci"
	fi

	(
	    cd ${out_dir}
	    generate_base_config ${container_name}
	)

	if [ "${container_type}" == "cube" ]; then
	    convert_base_config_to_cube ${container_name}
	fi
	;;
    mount)
	name_temp=${cmd_options_non_dashed[1]}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts mount
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 2 ]; then
	    # we have <type>:<source>:<dest>
	    source=$(echo ${name_temp} | cut -f2 -d:)
	    dest=$(echo ${name_temp} | cut -f3 -d:)

	    # save the mount information for the generation phase
	    echo "$source:$dest"  >> ${out_dir}/.cube.mount.bind
	elif [ ${colons} -eq 1 ]; then
	    # we have <source>:<dest>
	    source=$(echo ${name_temp} | cut -f1 -d:)
	    dest=$(echo ${name_temp} | cut -f2 -d:)

	    # save the mount information for the generation phase
	    echo "$source:$dest" >> ${out_dir}/.cube.mount
	else
	    echo "ERROR: Invalid mount specified ${name_temp}"
	    exit 1
	fi
	;;
    hook|hook-script)
	# drop "hook" from the command options, and then output everything
	# after it. We'll have a <type>:<command> in name_temp.
	name_temp=${cmd_options_non_dashed[@]:1}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts hooks
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 1 ]; then
	    # we have <source>:<dest>
	    type=$(echo ${name_temp} | cut -f1 -d:)
	    hookname=$(echo ${name_temp} | cut -f2 -d:)

	    if [ "${cmd}" == "hook-script" ]; then
		# When we later generate hooks, spaces in the hook definition
		# are processed as args to the executable. Due to the way
		# that shell scripts are invoked as hooks, we need all of the
		# script paramaters to be a single arg. To make sure this
		# happens, we replaces spaces with a placeholder ##space##
		# that will be converted back to spaces later
		hookname=$(echo ${hookname} | sed 's/ /##space##/g')
		hookname="/bin/sh -c ${hookname}"
	    fi

	    if [ "${type}" == "prestart" ]; then
		echo "${hookname}" >> ${out_dir}/.cube.hooks.prestart
	    elif [ "${type}" == "poststop" ]; then
		echo "${hookname}" >> ${out_dir}/.cube.hooks.poststop
	    else
		echo "ERROR: invalid hook type specified ${type}"
		exit 1
	    fi
	else
	    echo "ERROR: Invalid hook specified ${name_temp}"
	    exit 1
	fi
	;;
    device|dev)
	name_temp=${cmd_options_non_dashed[1]}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts device
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 2 ]; then
	    # we have <type>:<source>:<dest>
	    device_type=$(echo ${name_temp} | cut -f1 -d:)
	    essential_device=$(echo ${name_temp} | cut -f2 -d:)
	    container_device=$(echo ${name_temp} | cut -f3 -d:)

	    # save the mount information for the generation phase
	    case "${device_type}" in
		network)
		    echo "$essential_device:$container_device"  >> ${out_dir}/.cube.device.network
		    ;;
		network-virt)
		    echo "veth:$essential_device:$container_device"  >> ${out_dir}/.cube.device.network
		    ;;
	    esac
	else
	    echo "ERROR: Invalid device specified ${name_temp}"
	    exit 1
	fi
	;;
    set|get)
	var_value=${cmd_options_non_dashed[1]}
	var=$(echo ${var_value} | cut -d: -f1)
	value=$(echo ${var_value} | cut -d: -f2)

	if [ -z "${CONFIG_MAP[$var]}" ]; then
	    echo $var | grep -q /
	    if [ $? -ne 0 ]; then
		echo "[ERROR]: '$var' is not a known setting"
		exit 1
	    else
		etcd=t
		db_var="$var"
	    fi
	else
	    db_var=$(echo "${CONFIG_MAP[$var]}" | cut -f1 -d\;)
	fi

	# note: the backend that stores these values will change over time
	#       for now, it is a simple on-disk file. It could be a git config
	#       format file, etcd, or a database in the future

	if [ -n "${etcd}" ]; then
	    # if there's a / in the variable, it is destined for a data
	    # store. Note: this could also be a flag to the call, i.e. --etcd
	    # but lets go with this for now
	    if [ ${cmd} = "set" ]; then
		## TODO: if "value" is empty we should be deleting the key, right now
		##       there is no way to do it.
		inject_to_etcd ${var} ${value}
	    else
		fetch_from_etcd ${var}
	    fi
	else
	    if [ "${cmd}" = "set" ]; then
		echo "${value}" > ${out_dir}/${db_var}
	    else
		if [ -e "${out_dir}/cube.app" ]; then
		    cat "${out_dir}/cube.app"
		else
		    echo ""
		fi
	    fi
	fi
	;;
    *)
	echo "Unknown command ..."
	usage
	;;
esac
