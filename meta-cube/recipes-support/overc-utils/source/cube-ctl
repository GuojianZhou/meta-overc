#!/bin/bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

usage()
{
cat << EOF

  cube-ctl <options> <cmd>

commands (and options):

 ${0##*/} start [--peer] [--nested] [--auto] <name>

    start (launch) a container:

       --auto=<name>: launch autostart containers tagged with <name>

       <name>: name of the container to be launched (if not "--auto")

 ${0##*/} stop <name>

    stop a container:

       <name>: name of the container to be stopped

 ${0##*/} add [-n <name>] [-u <subuid>] <source tar.bz2>

    add a container to the platform. Once added, the container is monitored, but
    not started. Use "cube-ctl start" to launch a container after adding it.

       -n <name>: name of the container once added to the system. If this is
                  not supplied, the container source tarball is used to generate
                  a name.

       -u: make this newly added container unprivileged. The subuid field will
           be used to set the owner of the uid/gid in the root namespace for the
           newly added container. If no subuid field is provided, a default
           value of 800000 will be used.
 
       -o: if adding the container locally, the target directory for the rootfs

       -t: container type: lxc, oci or cube (default: oci)

       --auto=<name>: auto start the container, tag with <name>

       <source>: path to the container source (tar.bz2)

 ${0##*/} del [-F] <name>

    remove a container from the system. Once this completes, the container is
    stopped and purged from the filesystem.

       -F force remove container without prompting

 ${0##*/} status
 ${0##*/} list

    show the status (list) of known containers

 ${0##*/} <target>:<command>

    execute command <command> against a named target. Either a container
    name should be specified, or "host" for a native command.

 ${0##*/} info <name>

    display detailed information about container <name>

 ${0##*/} restart <name>

    restart container <name>. A graceful shutdown and relaunch will be
    performed.

EOF
}

if [ -z "$1" ]; then
    usage
    exit
fi

# take the entire command into an array
raw_command=($@)

force=""
peer=t
non_dashed=""

# this corresponds to the lxc.id_map items within the container's config file
DEFAULT_SUBUID=800000

while [ $# -gt 0 ]; do
    case "$1" in
	-v) verbose=t
            ;;
        --peer)
	    peer=t
	    nested=
	    ;;
        --auto)
	    auto=${2}
	    shift
	    ;;
	--nested)
	    nested=t
	    peer=
	    ;;
	--parent)
	    parent=${2}
	    shift
	    ;;
	-u)
		# This is an unprivileged container. We need to config subuid/subgid.
		if [ "${2}" -eq "${2}" ] 2>/dev/null; then
			if [ "${2}" -lt 100000 ] 2>/dev/null; then
				echo "Error: -u requires a subuid number no less than 100000"
				exit 1
			fi
			subuid="${2}"
			shift
		else
			subuid="${DEFAULT_SUBUID}"
		fi
		;;
	-F)
	    force=-F
	    ;;
        --n|-n)
	    container_name=${2}
	    shift
	    ;;
        --t|-t)
	    container_type=${2}
	    shift
	    ;;
        --o|-o)
	    out_dir=${2}
	    shift
	    ;;
	-h|--help)
	    usage
	    exit
	    ;;
	--*)
	    # if the next argument is dashed, we just add $1 to our collection
	    # of dashed arguments. If $2 is NOT dashed, we assume it is a parameter
	    # to the --dashed option, and we grab it as well. Don't try and mix
	    # dashed and non-dashed, since we'll grab them!
	    case $2 in
		--*)
		    dashed="${dashed} $1"
		    ;;
		*)
		    # sneak a : in between, so we can split it later
		    dashed="${dashed} $1:$2"
		    shift
		    ;;
	    esac
	    ;;
	*:*)
	    # once we see something of the format <foo>:<var>, we are done processing,
	    # since all other options are for the embedded command
	    cmd=exec
	    exec_cmd=$@
	    shift $#
	    ;;
        *) non_dashed="${non_dashed} $1"
            ;;
    esac
    shift
done

container_dir="/opt/container"
dom0ctl="/opt/dom0-contctl/dom0_contctl"
overc_cctl="/opt/overc-installer/overc-cctl"

if [ -f "${dom0ctl}" ]; then
    we_are_dom0=t
fi

# returns 1 if we are container, 0 otherwise
function am_i_a_container()
{
    which systemd-detect-virt
    if [ $? -eq 0 ]; then
	local virt=`systemd-detect-virt`
	if [ "${virt}" = "lxc" ]; then
	    return 1
	fi
    fi

    return 0
}

if [ -d "/host/proc" ]; then
    we_are_dom0=t
fi
am_i_a_container
if [ $? -eq 0 ]; then
    we_are_a_container=t
fi

# make an array from whatever was non-dashed
cmd_options_non_dashed=(${non_dashed})

if [ -z "${cmd}" ]; then
    # the first element is the command
    cmd=${cmd_options_non_dashed[0]}
fi

check_required()
{
    if [ ! -e "${1}" ]; then
	echo "[ERROR]: required command ${1} not found, exiting"
	exit 1
    fi
}

check_if_present()
{
    if [ -e "${1}" ]; then
	return 0
    fi
    return 1
}

# Check if the passed string matches any known container names
# return false (1) if unknown, true (0) if known
# additionally sets the global ${containers}
check_is_known_container()
{
    container_name=$1

    if [ -n "${we_are_dom0}" ]; then
	containers="`cube-cmd lxc-ls`"
	if [ -n "${containers}" ]; then
	    echo ${containers} | grep -q -w ${container_name}
	    if [ $? -ne 0 ]; then
		return 1
	    fi
	fi
    else
	return 1
    fi

    return 0
}

tweak_container_fstab()
{
    local rootfs=$1

    # Remove the systemd's costly remount of the root partition from /etc/fstab,
    # and also remove API filesystems mounting from it, as systemd will mount them itself.
    if [ -e ${rootfs}/etc/fstab ] ; then
	sed -i '\/dev\/root/d' ${rootfs}/etc/fstab
	sed -i '/^proc/d' ${rootfs}/etc/fstab
	sed -i '/^devpts/d' ${rootfs}/etc/fstab
	sed -i '/^tmpfs/d' ${rootfs}/etc/fstab
	sed -i '/^usbdevfs/d' ${rootfs}/etc/fstab
    fi
}

#
# arg1: the container type
# arg2: the container directory (note: *not* the rootfs dir)
#
# We generate a base configuration, and then tweak it for the
# various container formats.
#
generate_container_config()
{
    local ctype=$1
    local cdir=$2

    cat << EOF >${pathtocontainer}/config
lxc.utsname = ${cn}
lxc.rootfs = ${lxcbase}/${cn}/rootfs
lxc.autodev = 1
lxc.kmsg = 0
lxc.tty = ${tty_num}
lxc.pts = 0
lxc.mount = ${lxcbase}/${cn}/fstab
lxc.network.type = veth
lxc.network.name = veth0
lxc.network.script.up = /etc/lxc/ovs-up
lxc.network.script.down = /etc/lxc/ovs-down
lxc.group = ${group}
lxc.start.auto = ${autostart}
overc.start.auto = ${peerstart}
EOF
	if [ ${cn} == "dom0" ]; then
		echo "lxc.uncontain = 1" >> ${pathtocontainer}/config
	fi
	if [ ${bridged_net} == 1 ]; then
		sed -i '/^lxc.network.script.*$/d' ${pathtocontainer}/config
		sed -i '/^lxc.network.type.*$/a lxc.network.link = br0' \
		    ${pathtocontainer}/config
	fi
	if [ ${domain0} == 1 ]; then
		# Domain 0 wants to drive X onto a real console
		echo "lxc.console = none" >>${pathtocontainer}/config
	fi

	if [ -n "${subuid}" ]; then
		# for unprivileged containers, we need to use the mixed structure to
		# isolate the control of the container itself from the upper layer.
		echo "lxc.mount.auto = cgroup:mixed proc:mixed sys:mixed" >>${pathtocontainer}/config
		# subuid/subgid configuration for unprivileged container
		echo "lxc.id_map = u 0 ${subuid} 65536" >>${pathtocontainer}/config
		echo "lxc.id_map = g 0 ${subuid} 65536" >>${pathtocontainer}/config
	else
		# privileged containers
		echo "lxc.mount.entry = devpts ${lxcbase}/${cn}/rootfs/dev/pts devpts gid=5,mode=620 0 0" >>${pathtocontainer}/config
		echo "lxc.mount.entry = proc ${lxcbase}/${cn}/rootfs/proc    proc defaults 0 0" >>${pathtocontainer}/config
		echo "lxc.mount.entry = sysfs ${lxcbase}/${cn}/rootfs/sys     sysfs defaults 0 0" >>${pathtocontainer}/config
		echo "lxc.hook.autodev = ${lxcbase}/${cn}/autodev" >>${pathtocontainer}/config
	fi

	if [ -f "etc/system-id" ] || [ -f "/etc/system-id" ]; then
		echo "lxc.mount.entry = /etc/system-id ${lxcbase}/${cn}/rootfs/etc/system-id none ro,bind,optional,create=file" >>${pathtocontainer}/config
	fi

	lxcbase=$temp_lxcbase
	if [ ${havettyconsole} == 1 ]; then
		echo "overc.screen-getty = 1" >>${pathtocontainer}/config
	fi
}

case "${cmd}" in
    add)
	if [ -z "${container_type}" ]; then
	    container_type="oci"
	fi
	# the first non dashed argument will be the container source
	container_source=${cmd_options_non_dashed[1]}

	for o in ${dashed}; do
	    case ${o} in
		-n*)
		    container_name=`echo $o | cut -d: -f2`
		    ;;
		*)
		    echo "Unknow parameter ..."
		    usage
		    exit
		    ;;
	    esac
	done

	# if no name was provided, we just generate one from the source
	if [ -z "${container_name}" ]; then
	    filename=$(basename "$container_source")
	    extension="${filename##*.}"
	    filename="${filename%%.*}"
	    container_name="`cubename ${filename}`"
	fi

	# unprivileged. create default subuid/subgids for root and pass the
	# parameter to overc_cctl for container settings
	if [ -n "${subuid}" ]; then
	    if [ -n "${we_are_a_container}" ]; then
		privilege_param="-u ${subuid}"
		cube-cmd cmd "touch /etc/subuid /etc/subgid"
		cube-cmd cmd "usermod --add-subuids ${subuid}-$(( subuid+65536 )) root"
		cube-cmd cmd "usermod --add-subgids ${subuid}-$(( subuid+65536 )) root"
	    else
		touch /etc/subuid /etc/subgid
		usermod --add-subuids ${subuid}-$(( subuid+65536 )) root
		usermod --add-subgids ${subuid}-$(( subuid+65536 )) root
	    fi
	fi

	# regardless of the container type, we unpack the container source
	if [ -z "${out_dir}" ]; then
	    out_dir="${container_dir}/"
	fi

	echo "[INFO] Installing container ${container_name} to ${out_dir}"
	echo "[INFO] Extracting rootfs....."
	mkdir -p "${out_dir}/${container_name}/rootfs"
	tar --numeric-owner -xf ${container_source} -C ${out_dir}/${container_name}/rootfs
	if [ $? != 0 ]; then
		echo "[ERROR]: rootfs file extraction failed"
		exit 1
	fi
	echo "[INFO] Succeeded"

	if [ -n "${subuid}" ]; then
	    if [ -n "${we_are_a_container}" ]; then
		cube-cmd cmd "chown -R ${subuid}:${subuid} ${out_dir}/${container_name}/rootfs"
	    else
		chown -R ${subuid}:${subuid} ${out_dir}/${container_name}/rootfs
	    fi
	fi

	# cube (pflask)
	if [ "${container_type}" = "cube" ]; then
	    echo "[INFO] Performing cube configuration ..."
	    (
		cd ${out_dir}/${container_name}
		${SBINDIR}/cube-cfg mount bind:/opt/container:/opt/container
		${SBINDIR}/cube-cfg gen ${container_name}:cube
	    )

	    tweak_container_fstab ${out_dir}/${container_name}/rootfs

	    if [ -n "${auto}" ]; then
		echo "${auto}" > ${out_dir}/${container_name}/autostart
	    fi
	fi

	# OCI (runc)
	if [ "${container_type}" = "oci" ]; then
	    echo "[INFO] Performing OCI configuration ..."
	    (
		cd ${out_dir}/${container_name}
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube/all:/var/lib/cube/common
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube/${container_name}:/var/lib/cube/local
		${SBINDIR}/cube-cfg gen ${container_name}:oci

		# dom0 will have comms to these containers, so we need to create some directories
		# in its structure
		mkdir -p ${out_dir}/dom0/rootfs/var/lib/cube/all
		mkdir -p ${out_dir}/dom0/rootfs/var/lib/cube/${container_name}
	    )

	    tweak_container_fstab ${out_dir}/${container_name}/rootfs

	    if [ -n "${auto}" ]; then
		echo "${auto}" > ${out_dir}/${container_name}/autostart
	    fi
	fi

	# LXC (lxc)
	if [ "${container_type}" = "lxc" ]; then
	    echo "[INFO] Performing lxc configuration ..."
	    check_required ${overc_cctl}
	    ${overc_cctl} add ${privilege_param} -d -a -c -g onboot -t 0 -n ${container_name} -f ${container_source}
	    if [ $? != 0 ]; then
		echo "Add container failed ..."
		exit 1
	    fi
	fi

	if [ -n "${we_are_dom0}" ]; then
	    # now we need to restart the command server, so the new container can be monitored
	    systemctl restart cube-cmd-server
	fi
	;;
    del|delete|remove)
	check_required ${overc_cctl}
	check_required ${dom0ctl}

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if ! check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} not found, cannot remove."
	    echo -n "Valid containers are: "
	    echo ${containers}
	    exit 1
	fi

	echo "[INFO] stopping container ${container_name}"
	${dom0ctl} stop -n ${container_name}

	# now nuke it
	echo "[INFO] removing container ${container_name}"
	${overc_cctl} delete ${force} -n ${container_name}
	;;
    start)
	# the second non dashed argument will be the container name
	container_names=${cmd_options_non_dashed[1]}

	# if single_launch is set, then we don't use dtach, but instead let the
	# container go directly at the tty
	single_launch=t

	# TODO: this currently only supports autostart containers on the local
	#       machine. remote container start needs to be added.
	if [ -n "${auto}" ]; then
	    echo "[INFO] auto starting containers ..."
	    for c in $(ls "${container_dir}/"); do
		if [ -d "${container_dir}/${c}" ]; then
		    if [ -e "${container_dir}/${c}/autostart" ]; then
			grep -q ${auto} "${container_dir}/${c}/autostart"
			if [ $? -eq 0 ]; then
			    container_names="${container_names} $(basename ${c})"
			fi
		    fi
		fi
	    done
	fi

	for container in ${container_names}; do
	    echo "[INFO]: autostarting $container ..."
	    if [ -n "${single_launch}" ]; then
		if [ -e "${container_dir}/${container}/pflask.cmd" ]; then
		    ${container_dir}/${container}/pflask.cmd
		elif [ -e "${container_dir}/${container}/config.json" ]; then
		    (
			cd ${container_dir}/${container}
			runc create --console=/dev/ptmx ${container}
			runc start ${container}
		    )
		fi
	    else
		if [ -e "${container_dir}/${container}/pflask.cmd" ]; then
		    rm -f /tmp/${container}-console
		    dtach -n /tmp/${container}-console ${container_dir}/${container}/pflask.cmd
		fi
	    fi
	done
	;;
    status|list)
	check_if_present ${dom0ctl}
	if [ $? -eq 0 ]; then
	    ${dom0ctl} list
	else
	    cube-cmd lxc-ls
	fi
	;;
    info)
	check_required ${dom0ctl}
	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}
	${dom0ctl} info -n ${container_name}
	;;
    restart)
	check_required ${dom0ctl}
	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}
	${dom0ctl} relaunch -n ${container_name}
	;;
    stop)
	check_required ${dom0ctl}

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if ! check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} not found, cannot stop."
	    echo -n "Valid containers are: "
	    echo ${containers}
	    exit 1
	fi
	echo "[INFO] stopping container ${container_name}"
	if ! ${dom0ctl} stop -n ${container_name}; then
	    if ${dom0ctl} info -n ${container_name} | grep -q "State:[[:space:]]*STOPPED"; then
		echo "[ERROR] Stopping ${container_name} encountered issues."
		echo "[ERROR] Container ${container_name} might have already been stopped."
	    fi
	    exit 1
	fi
	;;
    exec)
	if [ -n "${we_are_a_container}" ]; then
	    echo "ERROR: host detected, cube-ctl only works in a monitored container."
	    echo "       Commands must be directly invoked in essential, control functions"
	    echo "       via the control domain."
	    exit 1
	fi

	# this is execute: <target>:<command>

	# remove the : separator
	non_dashed_no_colon=`echo ${exec_cmd[@]} | sed 's/:/ /g'`
	# make an array so we can yank out the name and command
	cmd_options_non_dashed=(${non_dashed_no_colon})

	# the container name is the first element
	container_name=${cmd_options_non_dashed[0]}

	# remove the first option from the command, we'll be passing it along, unprocessed
	cmd_to_exec=("${cmd_options_non_dashed[@]:1}")

	if [ "${container_name}" = "host" ] || [ "${container_name}" = "essential" ]; then
	    if [ -n "${verbose}" ]; then
		echo "running: cube-cmd ${cmd_to_exec[@]}"
	    fi

	    cube-cmd cmd ${cmd_to_exec[@]}
	else
	    check_required ${dom0ctl}

	    if [ -n "${verbose}" ]; then
		echo "running: ${dom0ctl} exec-cmd -n ${container_name} ${cmd_to_exec[@]}"
	    fi

	    ${dom0ctl} exec-cmd -n ${container_name} ${cmd_to_exec[@]}
	fi
	;;
    *)
	echo "Unknown command ..."
	usage
	;;
esac
