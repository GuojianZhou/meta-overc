#!/bin/bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

if [ "$CUBE_DEBUG_SET_X_IF_SET" = 1 ] ; then
    set -x
fi

usage()
{
cat << EOF

  cube-ctl <options> <cmd>

commands (and options):

 ${0##*/} start [--peer] [--nested] [--auto] <name>

    start (launch) a container:

       --auto=<name>: launch autostart containers tagged with <name>

       <name>: name of the container to be launched (if not "--auto")

 ${0##*/} stop <name>

    stop a container:

       <name>: name of the container to be stopped

 ${0##*/} add [-n <name>] [-u <subuid>] <source>

    add a container to the platform. Once added, the container is monitored, but
    not started. Use "cube-ctl start" to launch a container after adding it.

       -n <name>: name of the container once added to the system. If this is
                  not supplied, the container source tarball is used to generate
                  a name.

       -u: make this newly added container unprivileged. The subuid field will
           be used to set the owner of the uid/gid in the root namespace for the
           newly added container. If no subuid field is provided, a default
           value of 800000 will be used.
 
       -o: if adding the container locally, the target directory for the rootfs

       -t: container type: lxc, oci or cube (default: oci)

       --auto=<name>: auto start the container, tag with <name>

       <source>: path to the container source. Either a directory or a tar.gz

 ${0##*/} del [-F] <name>

    remove a container from the system. Once this completes, the container is
    stopped and purged from the filesystem.

       -F force remove container without prompting

 ${0##*/} status
 ${0##*/} list

    show the status (list) of known containers

 ${0##*/} <target>:<command>

    execute command <command> against a named target. Either a container
    name should be specified, or "host" for a native command.

 ${0##*/} info <name>

    display detailed information about container <name>

EOF
}

if [ -z "$1" ]; then
    usage
    exit
fi

# take the entire command into an array
raw_command=($@)

force=""
peer=t
non_dashed=""

if [ -z "${SBINDIR}" ]; then
    SBINDIR="/usr/sbin"
fi

# this corresponds to the lxc.id_map items within the container's config file
DEFAULT_SUBUID=800000

while [ $# -gt 0 ]; do
    case "$1" in
	-v) verbose=t
            ;;
        --peer)
	    peer=t
	    nested=
	    ;;
        --auto)
	    auto=${2}
	    shift
	    ;;
	--nested)
	    nested=t
	    peer=
	    ;;
	--parent)
	    parent=${2}
	    shift
	    ;;
	-u)
	    # This is an unprivileged container. We need to config subuid/subgid.
	    if [ "${2}" -eq "${2}" ] 2>/dev/null; then
		if [ "${2}" -lt 100000 ] 2>/dev/null; then
		    echo "Error: -u requires a subuid number no less than 100000"
		    exit 1
		fi
		subuid="${2}"
		shift
	    else
		subuid="${DEFAULT_SUBUID}"
	    fi
	    ;;
	-F)
	    force=-F
	    ;;
        --n|-n)
	    container_name=${2}
	    shift
	    ;;
        --t|-t)
	    container_type=${2}
	    shift
	    ;;
        --o|-o)
	    out_dir=${2}
	    shift
	    ;;
	-h|--help)
	    usage
	    exit
	    ;;
	--*)
	    # if the next argument is dashed, we just add $1 to our collection
	    # of dashed arguments. If $2 is NOT dashed, we assume it is a parameter
	    # to the --dashed option, and we grab it as well. Don't try and mix
	    # dashed and non-dashed, since we'll grab them!
	    case $2 in
		--*)
		    dashed="${dashed} $1"
		    ;;
		*)
		    # sneak a : in between, so we can split it later
		    dashed="${dashed} $1:$2"
		    shift
		    ;;
	    esac
	    ;;
	*://*)
	    non_dashed="${non_dashed} $1"
	    ;;
	*:*)
	    # once we see something of the format <foo>:<var>, we are done processing,
	    # since all other options are for the embedded command
	    cmd=exec
	    exec_cmd=$@
	    shift $#
	    ;;
        *) non_dashed="${non_dashed} $1"
            ;;
    esac
    shift
done

container_dir="/opt/container"
overc_cctl="/opt/overc-installer/overc-cctl"

# returns 1 if we are container, 0 otherwise
function am_i_a_container()
{
    local virt_bin=$(which systemd-detect-virt)

    # if we can't run detection, just say we aren't a container
    if [ -z "${virt_bin}" ]; then
	return 0
    fi

    local virt=$(systemd-detect-virt)
    case $virt in
	lxc*)
	    return 1
	    ;;
	container*)
	    return 1
	    ;;
	docker*)
	    return 1
	    ;;
    esac

    return 0
}

# only dom0 has visibility to essential
if [ -d "/var/lib/cube/essential" ]; then
    we_are_dom0=t
fi
am_i_a_container
if [ $? -eq 1 ]; then
    we_are_a_container=t
fi

# make an array from whatever was non-dashed
cmd_options_non_dashed=(${non_dashed})

if [ -z "${cmd}" ]; then
    # the first element is the command
    cmd=${cmd_options_non_dashed[0]}
fi

check_required()
{
    if [ ! -e "${1}" ]; then
	echo "[ERROR]: required command ${1} not found, exiting"
	exit 1
    fi
}

check_if_present()
{
    if [ -e "${1}" ]; then
	return 0
    fi
    return 1
}

# outputs:
#   machines: raw output from machinectl
#   oci: raw output from runc
#
#   cubes: list of running cubes
#   open_containers: list of running open containers
build_container_lists()
{
    # there are cubes, find them via machinectl
    machines="$(cube-cmd machinectl)"
    # drop the machinectl count of machines
    machines=$(echo "${machines}" | sed '/machines listed/d')

    # and then there are open containers
    graft_binaries_to_essential runc
    if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	runc_essential="/var/lib/cube/essential/sbin/runc"
    else
	echo "ERROR: unable to execute runc on essential"
	exit 1
    fi
    oci=$(cube-cmd ${runc_essential} list)

    # and then there are all the possible containers, which are
    # all found in /opt/container/<name>. We can tell the difference
    # between oci and cubes by the config files in the directory
    containers_available=$(ls /opt/container/)
    for c in ${containers_available}; do
	if [ -e "/opt/container/${c}/pflask.cmd" ]; then
	    cubes_available="${cubes_available} ${c}"
	elif [ -e "/opt/container/${c}/config.json" ]; then
	    open_container_available="${open_container_available} ${c}"
	fi
    done

    # short form output
    OLDIFS=$IFS
IFS="
"
    for l in ${machines} ${oci}; do

	# collapse all whitespace to a single space for the cut lines below
	l=$(echo ${l} | sed -e "s/[[:space:]]\+/ /g")

	case ${l} in
	    MACHINE*)
		# do nothing, it's a header from machinectl
		ctype="cube"
		;;
	    ID*)
		# do nothing, it's a header from runc
		ctype="oci"
		;;
	    *)
		cname=$(echo "${l}" | cut -f 1 -d' ')
		cstate=$(echo "${l}" | cut -f 3 -d' ')
		if [ "${ctype}" == "cube" ]; then
		    cubes="${cubes} ${cname}"
		fi
		if [ "${ctype}" == "oci" ]; then
		    open_containers="${open_containers} ${cname}"
		fi

		case $cstate in
		    stopped)
			if [ "${ctype}" == "oci" ]; then
			    open_container_stopped="${open_container_stopped} ${cname}"
			    open_container_available=$(echo ${open_container_available} | sed "s/${cname}//")
			fi
			;;
		    *)
			# if we don't recognize the state .. assume it is running
			if [ "${ctype}" == "oci" ]; then
			    open_container_running="${open_container_running} ${cname}"
			    open_container_available=$(echo ${open_container_available} | sed "s/${cname}//")
			fi
			if [ "${ctype}" == "cube" ]; then
			    cubes_running="${cubes_running} ${cname}"
			    cubes_available=$(echo ${cubes_available} | sed "s/${cname}//")
			fi
			;;
		esac
		;;
	esac
    done
    IFS=$OLDIFS
}

# Check if the passed string matches any known container names
# return false (1) if unknown, true (0) if known
# additionally sets the global ${containers}
check_is_known_container()
{
    container_name=$1

    # if we are not in a container .. then there's no need to check anything
    # just return that this is not a known container
    if [ -z "${we_are_a_container}" ]; then
	return 1
    fi

    build_container_lists

    if [ -n "${we_are_dom0}" ]; then
	echo ${cubes} | grep -q ${container_name}
	if [ $? -eq 0 ]; then
	    container_is_a_cube=t
	fi
	echo ${open_containers} ${open_container_available} | grep -q ${container_name}
	if [ $? -eq 0 ]; then
	    container_is_a_oci=t
	fi
	if [ -z "${container_is_a_cube}" ] && [ -z "${container_is_a_oci}" ]; then
	    return 1
	fi
    else
	return 1
    fi

    return 0
}

graft_binaries_to_essential()
{
    local binaries=$@

    if [ -z "${we_are_a_container}" ]; then
	return
    fi
    if [ -z "${we_are_dom0}" ]; then
	return
    fi

    if [ ! -d "/var/lib/cube/essential/sbin/" ]; then
	mkdir -p "/var/lib/cube/essential/sbin/"
    fi

    for b in ${binaries}; do
	if [ ! -e "/var/lib/cube/essential/sbin/${b}" ]; then
	    bin="${b}"
	    if [ ! -f "${bin}" ]; then
		bin=$(which ${b})
	    fi
	    if [ ! -f "${bin}" ]; then
		echo "ERROR: binary ${b} not found"
		continue
	    fi
	    cp ${bin} /var/lib/cube/essential/sbin/
	fi
    done
}

tweak_container_fstab()
{
    local rootfs=$1

    # Remove the systemd's costly remount of the root partition from /etc/fstab,
    # and also remove API filesystems mounting from it, as systemd will mount them itself.
    if [ -e ${rootfs}/etc/fstab ] ; then
	sed -i '\/dev\/root/d' ${rootfs}/etc/fstab
	sed -i '/^proc/d' ${rootfs}/etc/fstab
	sed -i '/^devpts/d' ${rootfs}/etc/fstab
	sed -i '/^tmpfs/d' ${rootfs}/etc/fstab
	sed -i '/^usbdevfs/d' ${rootfs}/etc/fstab
    fi
}

#
# arg1: the container type
# arg2: the container directory (note: *not* the rootfs dir)
#
# We generate a base configuration, and then tweak it for the
# various container formats.
#
generate_container_config()
{
    local ctype=$1
    local cdir=$2

    cat << EOF >${pathtocontainer}/config
lxc.utsname = ${cn}
lxc.rootfs = ${lxcbase}/${cn}/rootfs
lxc.autodev = 1
lxc.kmsg = 0
lxc.tty = ${tty_num}
lxc.pts = 0
lxc.mount = ${lxcbase}/${cn}/fstab
lxc.network.type = veth
lxc.network.name = veth0
lxc.network.script.up = /etc/lxc/ovs-up
lxc.network.script.down = /etc/lxc/ovs-down
lxc.group = ${group}
lxc.start.auto = ${autostart}
overc.start.auto = ${peerstart}
EOF
	if [ ${cn} == "dom0" ]; then
		echo "lxc.uncontain = 1" >> ${pathtocontainer}/config
	fi
	if [ ${bridged_net} == 1 ]; then
		sed -i '/^lxc.network.script.*$/d' ${pathtocontainer}/config
		sed -i '/^lxc.network.type.*$/a lxc.network.link = br0' \
		    ${pathtocontainer}/config
	fi
	if [ ${domain0} == 1 ]; then
		# Domain 0 wants to drive X onto a real console
		echo "lxc.console = none" >>${pathtocontainer}/config
	fi

	if [ -n "${subuid}" ]; then
		# for unprivileged containers, we need to use the mixed structure to
		# isolate the control of the container itself from the upper layer.
		echo "lxc.mount.auto = cgroup:mixed proc:mixed sys:mixed" >>${pathtocontainer}/config
		# subuid/subgid configuration for unprivileged container
		echo "lxc.id_map = u 0 ${subuid} 65536" >>${pathtocontainer}/config
		echo "lxc.id_map = g 0 ${subuid} 65536" >>${pathtocontainer}/config
	else
		# privileged containers
		echo "lxc.mount.entry = devpts ${lxcbase}/${cn}/rootfs/dev/pts devpts gid=5,mode=620 0 0" >>${pathtocontainer}/config
		echo "lxc.mount.entry = proc ${lxcbase}/${cn}/rootfs/proc    proc defaults 0 0" >>${pathtocontainer}/config
		echo "lxc.mount.entry = sysfs ${lxcbase}/${cn}/rootfs/sys     sysfs defaults 0 0" >>${pathtocontainer}/config
		echo "lxc.hook.autodev = ${lxcbase}/${cn}/autodev" >>${pathtocontainer}/config
	fi

	if [ -f "etc/system-id" ] || [ -f "/etc/system-id" ]; then
		echo "lxc.mount.entry = /etc/system-id ${lxcbase}/${cn}/rootfs/etc/system-id none ro,bind,optional,create=file" >>${pathtocontainer}/config
	fi

	lxcbase=$temp_lxcbase
	if [ ${havettyconsole} == 1 ]; then
		echo "overc.screen-getty = 1" >>${pathtocontainer}/config
	fi
}

#
# Command processing
#
# This is getting a bit large, and could be broken out into separate commands
# at some point, but for now, we leverage a common code base and set of 
# utility routines.
#
case "${cmd}" in
    add)
	if [ -z "${container_type}" ]; then
	    container_type="oci"
	fi
	# the first non dashed argument will be the container source
	container_source=${cmd_options_non_dashed[1]}

	if [ -z "${container_source}" ]; then
	    echo "[ERROR]: no container source provided"
	    exit 1
	fi

	for o in ${dashed}; do
	    case ${o} in
		-n*)
		    container_name=`echo $o | cut -d: -f2`
		    ;;
		*)
		    echo "Unknow parameter ..."
		    usage
		    exit 1
		    ;;
	    esac
	done

	# test to see if the container_source is a url!

	# extract the protocol
	proto="$(echo ${container_source} | grep :// | sed -e's,^\(.*://\).*,\1,g')"
	# remove the protocol
	url="$(echo ${container_source/$proto/})"
	# extract the user (if any)
	user="$(echo $url | grep @ | cut -d@ -f1)"
	# extract the host
	host="$(echo ${url/$user@/} | cut -d/ -f1)"
	# by request - try to extract the port
	port="$(echo $host | sed -e 's,^.*:,:,g' -e 's,.*:\([0-9]*\).*,\1,g' -e 's,[^0-9],,g')"
	# extract the path (if any)
	path="$(echo $url | grep / | cut -d/ -f2-)"

	if [ -n "${verbose}" ]; then
	    echo "url: $url"
	    echo "  proto: $proto"
	    echo "  user: $user"
	    echo "  host: $host"
	    echo "  port: $port"
	    echo "  path: $path"
	fi

	# if no name was provided, we just generate one from the source
	if [ -z "${container_name}" ]; then
	    filename=$(basename "$container_source")
	    extension="${filename##*.}"
	    filename="${filename%%.*}"
	    container_name="`cubename ${filename}`"
	fi

	if [ -z "${container_name}" ]; then
	    # try and see if the container_source was a url, and if so, the host
	    # name can be the container name
	    container_name=${host}
	    if [ -z "${container_name}" ]; then
		echo "[ERROR]: ${container_source} is not a valid container source location"
		exit 1
	    fi
	fi

	if check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} already exists, cannot add."
	    exit 1
	fi

	# unprivileged. create default subuid/subgids for root and pass the
	# parameter to overc_cctl for container settings
	if [ -n "${subuid}" ]; then
	    if [ -n "${we_are_a_container}" ]; then
		privilege_param="-u ${subuid}"
		cube-cmd cmd "touch /etc/subuid /etc/subgid"
		cube-cmd cmd "usermod --add-subuids ${subuid}-$(( subuid+65536 )) root"
		cube-cmd cmd "usermod --add-subgids ${subuid}-$(( subuid+65536 )) root"
	    else
		touch /etc/subuid /etc/subgid
		usermod --add-subuids ${subuid}-$(( subuid+65536 )) root
		usermod --add-subgids ${subuid}-$(( subuid+65536 )) root
	    fi
	fi

	# regardless of the container type, we unpack the container source
	if [ -z "${out_dir}" ]; then
	    out_dir="${container_dir}/"
	fi

	mkdir -p "${out_dir}/${container_name}/rootfs"
	case ${container_source} in
	    *.tar*)
		echo "[INFO] Installing container ${container_name} to ${out_dir}"
		echo "[INFO] Extracting rootfs....."
		tar --numeric-owner -xf ${container_source} -C ${out_dir}/${container_name}/rootfs
		if [ $? != 0 ]; then
		    echo "[ERROR]: rootfs file extraction failed"
		    exit 1
		fi
		;;
	    docker://*)
		# make an oci format copy from the registry
		skopeo copy ${container_source} oci:${out_dir}/${container_name}/docker 2> /dev/null
		if [ $? -ne 0 ]; then
		    echo "[ERROR]: docker container ${container_source} not found, check input and try again"
		    exit 1
		fi
	
		# TODO: allow the variation of the ref tag
		oci-create-runtime-bundle --ref latest ${out_dir}/${container_name}/docker ${out_dir}/${container_name}/oci-runtime
		if [ $? -ne 0 ]; then
		    echo "[ERROR]: error OCI runtime could not be created from ${container_source}"
		    exit 1
		fi

		if [ -f "${out_dir}/${container_name}/oci-runtime/config.json" ]; then
		    entry_point=$(jq -r '.process.args | .[]' ${out_dir}/${container_name}/oci-runtime/config.json)
		fi

		# recursive call!! This may mean we need an import tool front end, instead of doing this here
		cube-ctl add -n ${container_name} ${out_dir}/${container_name}/oci-runtime

		if [ -n "${entry_point}" ]; then
		    cube-cfg -n ${container_name} set app:${entry_point}
		    cube-cfg gen ${container_name}:oci
		fi

		rm -rf ${out_dir}/${container_name}/docker
		rm -rf ${out_dir}/${container_name}/oci-runtime

		exit 0
		;;
	    *)
		if [ -d ${container_source} ]; then
		    echo "[INFO] Adding ${container_source} to ${container_name}"

		    # could be further refined to pick up a config.json and do an
		    # oci maniplation, but for now, we just cp -ar
		    if [ -d ${container_source}/rootfs ]; then
			cp -ar ${container_source}/rootfs ${out_dir}/${container_name}
		    else
			cp -ar ${container_source}/* ${out_dir}/${container_name}/rootfs
		    fi
		else
		    echo "[ERROR]: unknown container source"
		    exit 1
		fi
		;;
	esac
	echo "[INFO] Succeeded"

	if [ -n "${subuid}" ]; then
	    if [ -n "${we_are_a_container}" ]; then
		cube-cmd cmd "chown -R ${subuid}:${subuid} ${out_dir}/${container_name}/rootfs"
	    else
		chown -R ${subuid}:${subuid} ${out_dir}/${container_name}/rootfs
	    fi
	fi

	# cube (pflask)
	if [ "${container_type}" = "cube" ]; then
	    echo "[INFO] Performing cube configuration ..."
	    (
		# make sure that /var/lib/cube/essential and local exist
		# in the essential directory structure

		# see if someone arranged for /var/lib/cube to be mounted into out_dir, if
		# not, we need to go directly at /var/lib/cube
		var_dir=""
		if [ -d "${out_dir}/var/lib/cube/" ]; then
		    var_dir="${out_dir}"
		fi
		mkdir -p ${var_dir}/var/lib/cube/essential
		mkdir -p ${var_dir}/var/lib/cube/local

		cd ${out_dir}/${container_name}
		${SBINDIR}/cube-cfg mount bind:/opt/container:/opt/container
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube:/var/lib/cube
		# cubes are priviledged. By default pflask will mount
		# /proc/sys as read-only. This means that things (like
		# docker) that need to modify sys parameters will fail. By
		# adding and extra mount of essential's /proc/sys to the
		# container /proc/sys, we'll end up with a r/w /proc/sys.
		${SBINDIR}/cube-cfg mount bind:/proc/sys:/proc/sys
		${SBINDIR}/cube-cfg gen ${container_name}:cube
	    )

	    tweak_container_fstab ${out_dir}/${container_name}/rootfs

	    if [ -n "${auto}" ]; then
		${SBINDIR}/cube-cfg -o ${out_dir}/${container_name} set autostart:${auto}
	    fi
	fi

	# OCI (runc)
	if [ "${container_type}" = "oci" ]; then
	    echo "[INFO] Performing OCI configuration ..."
	    (
		cd ${out_dir}/${container_name}
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube/all:/var/lib/cube/common
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube/${container_name}:/var/lib/cube/local

		${SBINDIR}/cube-cfg hook prestart:/usr/libexec/oci/hooks.d/oci-systemd-hook
		${SBINDIR}/cube-cfg hook-script prestart:/usr/libexec/oci/hooks.d/oci-network up \$\(cat\)
		${SBINDIR}/cube-cfg hook-script poststop:/usr/libexec/oci/hooks.d/oci-network down \$\(cat\)
		${SBINDIR}/cube-cfg hook poststop:/usr/libexec/oci/hooks.d/oci-systemd-hook

		${SBINDIR}/cube-cfg gen ${container_name}:oci

		# update the container manager
		graft_binaries_to_essential runc
		${SBINDIR}/cube-cfg set cube.container.mgr:/var/lib/cube/essential/sbin/runc

		# see if someone arranged for /var/lib/cube to be mounted into out_dir, if
		# not, we need to go directly at /var/lib/cube
		var_dir=""
		if [ -d "${out_dir}/var/lib/cube/" ]; then
		    var_dir="${out_dir}"
		fi

		# make the dirs in essential, but they will be bind mounted to the container
		mkdir -p ${var_dir}/var/lib/cube/all
		mkdir -p ${var_dir}/var/lib/cube/${container_name}
	    )

	    tweak_container_fstab ${out_dir}/${container_name}/rootfs

	    if [ -n "${auto}" ]; then
		${SBINDIR}/cube-cfg -o ${out_dir}/${container_name} set autostart:${auto}
	    fi
	fi

	# LXC (lxc)
	if [ "${container_type}" = "lxc" ]; then
	    echo "[INFO] Performing lxc configuration ..."
	    check_required ${overc_cctl}
	    ${overc_cctl} add ${privilege_param} -d -a -c -g onboot -t 0 -n ${container_name} -f ${container_source}
	    if [ $? != 0 ]; then
		echo "Add container failed ..."
		exit 1
	    fi
	fi

	if [ -n "${we_are_dom0}" ]; then
	    # now we need to restart the command server, so the new container can be monitored
	    systemctl restart cube-cmd-server
	fi
	;;
    del|delete|remove)
	graft_binaries_to_essential runc
	if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	    runc_essential="/var/lib/cube/essential/sbin/runc"
	else
	    echo "ERROR: unable to execute runc on essential"
	    exit 1
	fi

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if [ -z "${out_dir}" ]; then
	    out_dir="${container_dir}/"
	fi

	if ! check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} not found, cannot delete."
	    echo -n "Valid containers are: "
	    echo ${cubes} ${open_containers} ${open_container_available}
	    exit 1
	fi
	echo "[INFO] deleting container ${container_name}"

	if [ -n "${container_is_a_cube}" ]; then
	    # nothing to do at the moment
	    true
	fi
	if [ -n "${container_is_a_oci}" ]; then
	    # TODO: the container state needs to be tracked better, and only
	    #       do this if it is running
	    cube-cmd ${runc_essential} delete ${container_name} 2> /dev/null
	    if [ -d "${out_dir}/${container_name}" ]; then
		echo "[INFO] removing container source .."
		rm -rf "${out_dir}/${container_name}"
	    fi
	fi
	;;
    start)
	# the second non dashed argument will be the container name
	container_names=${cmd_options_non_dashed[1]}

	# if single_launch is set, then we don't use dtach, but instead let the
	# container go directly at the tty
	single_launch=t

	# The auto is the container tags that we should locate. If found, add them
	# to the container list
	if [ -n "${auto}" ]; then
	    echo "[INFO] auto starting containers ..."
	    for c in $(ls "${container_dir}/"); do
		if [ -d "${container_dir}/${c}" ]; then
		    if [ -e "${container_dir}/${c}/autostart" ]; then
			grep -q ${auto} "${container_dir}/${c}/autostart"
			if [ $? -eq 0 ]; then
			    container_names="${container_names} $(basename ${c})"
			fi
		    fi
		fi
	    done
	fi

	for container in ${container_names}; do
	    if [ -n "${single_launch}" ]; then
		if [ -e "${container_dir}/${container}/pflask.cmd" ]; then
		    ${container_dir}/${container}/pflask.cmd
		elif [ -e "${container_dir}/${container}/config.json" ]; then
		    (
			if [ -n "${we_are_dom0}" ]; then
			    # This escapes our namespace and launches the containers in our parents (essential)
			    # namespace. But in that structure, runc may not be available so we copy it first and
			    # then use it directly.
			    build_container_lists

			    echo "${open_container_running}" | grep -q ${container}
			    if [ $? -ne 0 ]; then
				nsenter -P -t 1 -p -n -u -m -C ${runc_essential} create --bundle /opt/container/${container} --console=/dev/ptmx ${container}
				nsenter -P -t 1 -p -n -u -m -C ${runc_essential} start ${container}

				cube-cfg set overc/containers/${container}/status:active
			    else
				echo "container ${container} is already running ..."
			    fi
			else
			    # TODO: use cube-cmd to talk to a remote container manager
			    true
			fi
		    )
		fi
	    else
		if [ -e "${container_dir}/${container}/pflask.cmd" ]; then
		    rm -f /tmp/${container}-console
		    dtach -n /tmp/${container}-console ${container_dir}/${container}/pflask.cmd
		fi
	    fi
	done
	;;
    status|list)
	build_container_lists

	if [ -n "${verbose}" ]; then
	    machines=$(echo "${machines}" | sed 's/^/   /')
	    oci=$(echo "${oci}" | sed 's/^/   /')
	    echo "cubes:"
	    echo ""
	    echo "${machines}"
	    echo ""
	    echo "open containers:"
	    echo ""
	    echo "${oci}"
	else
	    for l in ${open_container_running}; do
		echo "${l} # oci, running"
	    done
	    for l in ${open_container_stopped}; do
		echo "${l} # oci, stopped"
	    done
	    for l in ${cubes_running}; do
		echo "${l} # cube, running"
	    done
	    for l in ${open_container_available}; do
		echo "${l} # oci, available"
	    done
	    for l in ${cubes_available}; do
		echo "${l} # cube, available"
	    done
IFS=$OLDIFS
	fi
	;;
    info)
	build_container_lists

	graft_binaries_to_essential runc
	if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	    runc_essential="/var/lib/cube/essential/sbin/runc"
	else
	    echo "ERROR: unable to execute runc on essential"
	    exit 1
	fi

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if [ -n "${container_name}" ]; then
	    echo ${cubes} | grep -q ${container_name}
	    if [ $? -eq 0 ]; then
		container_is_a_cube=t
	    fi
	    echo ${open_containers} | grep -q ${container_name}
	    if [ $? -eq 0 ]; then
		container_is_a_oci=t
	    fi
	    if [ -z "${container_is_a_cube}" ] && [ -z "${container_is_a_oci}" ]; then
		echo "ERROR: container ${container_name} is not valid"
		exit 1
	    fi

	    if [ -n "${container_is_a_cube}" ]; then
		if [ -n "${verbose}" ]; then
		    cube-cmd machinectl status ${container_name}
		else
		    cube-cmd machinectl show ${container_name}
		fi
	    fi
	    if [ -n "${container_is_a_oci}" ]; then
		cube-cmd ${runc_essential} state ${container_name}
	    fi
	fi
	;;
    stop|pause)
	graft_binaries_to_essential runc
	if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	    runc_essential="/var/lib/cube/essential/sbin/runc"
	else
	    echo "ERROR: unable to execute runc on essential"
	    exit 1
	fi

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if ! check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} not found, cannot stop."
	    echo -n "Valid containers are: "
	    echo ${cubes} ${open_containers}
	    exit 1
	fi
	echo "[INFO] stopping container ${container_name}"

	if [ -n "${container_is_a_cube}" ]; then
	    cube-cmd machinectl stop ${container_name}
	fi
	if [ -n "${container_is_a_oci}" ]; then
	    cube-cmd ${runc_essential} kill ${container_name} KILL
	    if [ "${cmd}" == "stop" ]; then
		cube-cmd ${runc_essential} delete ${container_name}
	    fi
	    cube-cfg set overc/containers/${container_name}/status:inactive
	fi
	;;
    exec)
	if [ -z "${we_are_a_container}" ]; then
	    echo "ERROR: host detected, cube-ctl only works in a monitored container."
	    echo "       Commands must be directly invoked in essential, control functions"
	    echo "       via the control domain."
	    exit 1
	fi

	# this is execute: <target>:<command>

	# remove the : separator
	non_dashed_no_colon=`echo ${exec_cmd[@]} | sed 's/:/ /g'`
	# make an array so we can yank out the name and command
	cmd_options_non_dashed=(${non_dashed_no_colon})

	# the container name is the first element
	container_name=${cmd_options_non_dashed[0]}

	# remove the first option from the command, we'll be passing it along, unprocessed
	cmd_to_exec=("${cmd_options_non_dashed[@]:1}")

	if [ "${container_name}" = "host" ] || [ "${container_name}" = "essential" ]; then
	    if [ -n "${verbose}" ]; then
		echo "running: cube-cmd ${cmd_to_exec[@]}"
	    fi

	    cube-cmd cmd ${cmd_to_exec[@]}
	else
	    mgr=$(cube-cfg -o /opt/container/${container_name}/ get cube.container.mgr)
	    echo ${mgr} | grep -q runc
	    if [ $? -eq 0 ]; then
		cmd="cube-cmd ${mgr} exec -- ${container_name} ${cmd_to_exec}"
	    else
		echo "[ERROR]: no container manager identified, not executing command"
		exit 1
	    fi

	    if [ -n "${verbose}" ]; then
		echo "running: ${cmd}"
	    fi

	    eval ${cmd}
	fi
	;;
    *)
	echo "Unknown command ..."
	usage
	;;
esac
